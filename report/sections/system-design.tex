\section{System design and composition}
\subsection{Model}
The system is modeled in two parts: the moving base and the\ldots
% TODO: describe the moving base, and the attachment, whatever it ends up being.
% Include physical models.


% Describe the states of the system.
We argue for the following five states of the system:
\begin{inline-enum}
\item waiting for a command;
\item moving to a destination;
\item following a navigation-line;
\item picking an object up; and
\item dropping an object off.
\end{inline-enum}
The relation between these five states are visually described in the state machine of Fig~\ref{fig:state_machine}.
\begin{figure*}[ht]
  \centering
  \begin{tikzpicture}
    \node[state, initial, accepting] (wait) {waiting for \\ command};
    \node[state, right of=wait] (move) {moving to \\ destination};
    \node[state, below of=move] (follow) {following \\ line};
    \node[state, right of=follow] (pickup) {picking \\ up object};
    \node[state, left of=follow] (dropoff) {dropping \\ off object};

    \path[->] (wait) edge node{Arrowhead \\ signal} (move)
    (move) edge[sloped] node{line detected \\} (follow)
    (follow) edge[sloped] node{station detection \\ (system w/o object)} (pickup)
    (follow) edge[sloped] node{station detection \\ (system w/ object)} (dropoff)
    (pickup) edge[sloped] node{object picked up \\} (move)
    (dropoff) edge[sloped] node{object dropped \\} (wait)
    ;
  \end{tikzpicture}
  \caption{High-level state machine of the system.}
  \label{fig:state_machine}
\end{figure*}
\subsubsection{Mobile platform}
\label{subsubsec:unicycle}
The model used in this case is the unicycle model, due to the differential steering. 
This is because of the mobile platform has only two wheels/trucks and it is not able to apply any steering angle to its wheels. 
The only way this robot can change orientation is by giving different velocity on each wheel-driving servo on left- and right- side. 
With this feature it is also possible to change the orientation of the mobile platform without changing the position of the platform. 
I.e. the robot is able to spin while the right-hand sidewheels have the same velocity as the left-hand side wheels, in opposite direction.\\ 
\begin{figure}[h!]
\centering
\includegraphics[width=0.4\textwidth]{sections/assets/car-unicycle.png}
\caption{Unicycle model of a car-like robot. 
$v_L$ and $v_R$ represent the left- and right-hand side wheels' velocities respectively. 
The robot follows a path around the instantaneous center of rotation (ICR) where $R_L$ and $R_R$ are the distances from left and right wheels to ICR respectively and $w$ is the distance between them.}
\label{fig:UnicycleModel}
\end{figure} 

As shown in Fig.~\ref{fig:UnicycleModel} The robot follows a curved path with the instantaneous center of rotation at its center. 
The left-hand side wheels have velocity $v_L$ and moves along an arc with radius $R_L$ during the time that right-hand side wheels moves along another arc with radius $R_R$ at the speed of $v_R$. 
The turning rate of the body is
\begin{equation*}
\dot{\theta}= \frac{v_L}{R_L} = \frac{v_R}{R_R}
\end{equation*}

since $R_R = R_L + W$ the expression can be simplified as
\begin{equation}
\dot{\theta}= \frac{v_R - v_L}{W} = \frac{v_\Delta}{W}\label{eq:ThetaDot}
\end{equation}

the equations of motion for this model are
\begin{eqnarray}
\begin{aligned}
\dot{x} &= v\,cos(\theta)\\
\dot{y} &= v\,sin(\theta)\\
\dot{\theta} &= \omega = \frac{v_\Delta}{W}
\end{aligned}
\label{eq:MotionEq}
\end{eqnarray}

where the average velocity\parencite{Corke2011} is given by        
\begin{equation}
v = \frac{v_R + v_L}{2} 
\label{eq:av_velocity}
\end{equation}

\subsection{Simulation}
% Simulte the models from the previous section and show that it will work.
% Motivate regulation approach.
\subsubsection{Mobile platform}
A simulation profile is made to make sure of the unicycle mode in sub section \ref{subsubsec:unicycle} is the suitable model for this application.
The simulation is made in discrete time domain with the sampling frequency of $10Hz$.
This is done in the described way due to the robot is going to operate in discrete time.
The sampling frequency is assumed to be low and that is because the designed controllers are going to be able to work fine for higher samplings frequencies but that is not guaranteed for vise-versa.\\  
As the unicycle model describes the systems dynamics.
The position of the robot $(x, y, \theta)$ is dependent on the two wheel velocities. Which in turn has dependencies to the average velocity $V$ and the angular velocity $\omega$. These relations are presented in Eq.(\ref{eq:ThetaDot}) - Eq.(\ref{eq:av_velocity}).\\
\begin{figure*}[ht]
\centering
\includegraphics[width=\textwidth]{sections/assets/omegaCtrlr.png}
\caption{Overview of the systems block diagram where the angular velocity $\omega$ is controlled by a PID controller.}
\label{fig:overview}
\end{figure*} 

A pole placement analyze is required for the design of a PID controller.
This analyze is done in continues time domain, due to its simplicity.\\
As mentioned in Eq.(\ref{eq:MotionEq})
\begin{equation}
\dot{\theta} = \omega
\label{eq:omega}
\end{equation}

By taking the Laplace transform of Eq.(\ref{eq:omega}) gives:
\begin{equation}
s\cdot \Theta(s)= \Omega(s)
\end{equation}

Where $G(s)$ is the transfer function
\begin{equation}
\therefore G(s)=\frac{\Omega(s)}{s\cdot\Theta(s)} = 1
\end{equation}

However it is the angular position $\theta$ which is relevant in this case.
So it is required to implement an integrator in the feedback to make the angular position controllable.\\ \\
\tikzset{
    block/.style = {draw, rectangle, 
    minimum height=1cm, 
    minimum width=2cm},
    input/.style = {coordinate,node distance=1cm},
    output/.style = {coordinate,node distance=2cm},
    arrow/.style={draw, -latex,node distance=2cm},
    pinstyle/.style = {pin edge={latex-, black,node distance=2cm}},
    sum/.style = {draw, circle, node distance=1cm}
}
\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[auto, node distance=2.5cm,>=latex']
        \node [input, name=input] {};
        \node [sum, right of=input] (sum) {};
        \node [block, right of=sum] (controller) {$PID$};
        \node [block, right of=controller] (plant) {$G(s)$};
        \node [output, right of=plant] (output) {};
        \node [block, below of=plant] (feedback) {$\frac{1}{s}$};
        \draw [draw,->] (input) -- node {$U(s)$} (sum);
        \draw [->] (sum) -- node {} (controller);
        \draw [->] (controller) -- node {} (plant);
        \draw [->] (plant) -- node [name=y] {$Y(s)$}(output);
        \draw [->] (y) |- node [above,pos=0.79] {} (feedback) ;
        \draw [->] (feedback) -| node[pos=0.99] {$-$} 
        node [near end] {} (sum);
        \end{tikzpicture}
    \end{center}
    \caption{Closed Loop system with a integrator in the feedback.}\label{fig:closedloop}
\end{figure}

In this case the closed loop transfer function will be as shown in Eq.(\ref{eq:closedloop})
\begin{equation}
G_{c}(s) = \frac{PID}{s + PID}
\label{eq:closedloop}
\end{equation} 

As the closed loop transfer function of the system is describing a first order system, it is possible to use a P-controller. 
I.e. the controller only has a proportional gain and doesn't require a integrative or derivative elements. 
So the final closed loop transfer function will be 
\begin{equation}
G_{c}(s) = \frac{K_p}{s + K_p}
\label{eq:kp}
\end{equation}

This system will have a pole at $-K_p$.
Any positive proportional gain will results in a stable pole and which in turn a stable system. \\
\begin{figure*}[ht]
\centering
\includegraphics[width=\textwidth]{sections/assets/Theta_PID.PNG}
\caption{The complete control block for the angular position in discrete time domain.}
\label{fig:PID1}
\end{figure*}
\\
 
It is required to make sure that $\theta$ error, $\theta_e$ is in $(-\pi,\pi]$ span. Due to the $\theta = \theta \pm 2 \cdot n \cdot \pi$, it is possible for the error be in out of this span.
By using a function called arctan2 or atan2 in many programming languages it is possible to accomplish this challenge.\\
This function often has two input argument (y,x).\\ 
By defining 
\begin{equation}
\theta = atan2(sin(\theta),\, cos(\theta))
\end{equation}
$\theta$ will always be in $(-\pi,\pi]$ span.\\

Due to the physical limits the servos have, two saturation blocks are required.
These blocks are shown in figure(\ref{fig:PID1}) and the assumption for their limits are (-10,10) $[cm/sec]$. 
This assumption is done to make the simulation more alike the real application.\\
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\textwidth]{sections/assets/Theta_pi_stepresponce.png}
\caption{The step response for $\theta$ where the proportional gain $K_p = 4$ and the reference value is $\pi$ .}
\label{fig:Theta_Step}
\end{figure}

The result of the simulation, the step response for the angular position control system is presented in figure(\ref{fig:Theta_Step}).
As it shown this is a stable system, it has no steady state error, no oscillation and relative fast rise-time.\\

In this part of the mobile platforms movement it is important to be able to control the spacial position $(x, y)$. 
As shown in the kinematic equations Eq.(\ref{eq:MotionEq}) the positions are dependent on both the angular velocity $\omega$ and the average velocity $v$. 
A design of a controller for the average velocity is required to make it possible to control the spacial position. 
Take note of the two input $AverageVelocity$, $Desired\_Theta$ and the two output $x$, $y$ in figure(\ref{fig:PID1}).\\











\subsection{Hardware}
% Explain the raspberry pi and it's attachments.

\subsection{Software}
\subsubsection{Reproducible system image generation}
% Explain the repo's *.nix files and what they do
The system image of the Raspberry Pi is generated via the repository's \texttt{mmc-image.nix} file ---
an auxiliary \texttt{build.sh} script is available to generate and subsequently flash a target storage device in a single command execution.
\texttt{mmc-image.nix} contains an expression of the Nix language.
Together with the usage of \texttt{nixpkgs} --- an extensive library of build and package declarations,
\texttt{mmc-image.nix} allows us to reliably and reproducibly build a bootable image of the complete software environment the project requires.
To then boot the generated image, it only needs to be flashed on a MultiMediaCard (MMC\footnote{Commonly referred to as: SD card, memory card.}) and slotted into the MMC-slot on the Raspberry Pi.

% Explain the pros of Nix
When building derivations (nomenclature for anything built with Nix: an executable binary, shared library file, a system environment, etc.) their dependencies are in complete isolation with each other, which effectively allows the avoidance of dependency hell.\footnote{Colloquial term referring to the frustration often generated when dealing with version-specific dependencies.
See \href{https://en.wikipedia.org/wiki/Dependency_hell}{Wikipedia}.}

% Explain the rollback functionality git provide us.
In combination with git, one may trivially roll back to previous derivations that are known to work by checking out a commit and rebuilding.

% Explain why treating the MMC as volatile is a good idea (MMCs have a tendency to just stop working).
In addition, by preferring a work flow where the target storage is considered volatile, any deficiencies of the target medium are mitigated.

% TODO: improve
\subsubsection{System-external services}
The software environment generated for the Raspberry Pi automatically connects to Eduroam if credentials are available.
Eduroam places some limitations on connected clients: firewall, e.g.
To enable easy remote access to the system, a reverse SSH proxy is established with a known bastion host which has a static IP address.
By exposing this proxy via a known port on the bastion, any system connected to the Internet may trivially access the Raspberry Pi remotely via a static endpoint.
While not a necessity for the project itself, this external service is a great convenience for ad-hoc experiments and general system debugging.

% Explain the content of contrib/bastion.nix
